// Autogenerated by tracing_traits_generator, do not edit

#ifndef FCP_BASE_TRACING_SCHEMA_H
#define FCP_BASE_TRACING_SCHEMA_H

#ifdef FLATBUFFERS_GENERATED_TRACINGSCHEMA_H_
#undef FLATBUFFERS_GENERATED_TRACINGSCHEMA_H_
#endif
#include "fcp/base/tracing_schema_generated.h"
#include "absl/strings/string_view.h"
#include "fcp/tracing/tracing_severity.h"
#include "fcp/tracing/tracing_traits.h"
#include "flatbuffers/minireflect.h"
#include "flatbuffers/idl.h"
#include "fcp/base/platform.h"

namespace fcp {

template<> class TracingTraits<ProtoParseFailure>: public TracingTraitsBase {
 public:
  static constexpr TracingTag kTag = TracingTag("PRPR");
  static constexpr TracingSeverity kSeverity = fcp::TracingSeverity::kError;
  static constexpr bool kIsSpan = false;
  const char* Name() const override { return "ProtoParseFailure"; }
  TracingSeverity Severity() const override {
    return fcp::TracingSeverity::kError;
  }
  std::string TextFormat(const flatbuffers::DetachedBuffer& buf) const override {
    return flatbuffers::FlatBufferToString(buf.data(), ProtoParseFailureTypeTable());
  }
  std::string JsonStringFormat(const uint8_t* flatbuf_bytes) const override {
    flatbuffers::Parser parser;
    std::string schema_file;
    std::string fbs_file = "fcp/base/tracing_schema.fbs";
    flatbuffers::LoadFile(GetDataPath(fbs_file).c_str(), true, &schema_file);
    std::string schema_path_common = GetDataPath("fcp/tracing/tracing_schema_common.fbs");
    std::string directory_common = schema_path_common.substr(0, schema_path_common.find("fcp/tracing/tracing_schema_common.fbs"));
    const char *include_directories[] = {
                 directory_common.c_str(), nullptr};
    parser.Parse(schema_file.c_str(), include_directories);
    std::string jsongen;
    parser.SetRootType("ProtoParseFailure");
    GenerateText(parser, flatbuf_bytes, &jsongen);
    return jsongen;
  }
  static flatbuffers::Offset<ProtoParseFailure> Create(absl::string_view type, flatbuffers::FlatBufferBuilder* fbb) {
    auto type__ = fbb->CreateString(type.data(), type.size());
    return CreateProtoParseFailure(*fbb, type__);
  }
  using TupleType = std::tuple<std::string>;
  static TupleType MakeTuple(const ProtoParseFailure* table) {
    return std::make_tuple(table->type()->str());
  }
};
static internal::TracingTraitsRegistrar<ProtoParseFailure> registrar_ProtoParseFailure;
template<> class TracingTraits<ResultExpectError>: public TracingTraitsBase {
 public:
  static constexpr TracingTag kTag = TracingTag("!EXP");
  static constexpr TracingSeverity kSeverity = fcp::TracingSeverity::kError;
  static constexpr bool kIsSpan = false;
  const char* Name() const override { return "ResultExpectError"; }
  TracingSeverity Severity() const override {
    return fcp::TracingSeverity::kError;
  }
  std::string TextFormat(const flatbuffers::DetachedBuffer& buf) const override {
    return flatbuffers::FlatBufferToString(buf.data(), ResultExpectErrorTypeTable());
  }
  std::string JsonStringFormat(const uint8_t* flatbuf_bytes) const override {
    flatbuffers::Parser parser;
    std::string schema_file;
    std::string fbs_file = "fcp/base/tracing_schema.fbs";
    flatbuffers::LoadFile(GetDataPath(fbs_file).c_str(), true, &schema_file);
    std::string schema_path_common = GetDataPath("fcp/tracing/tracing_schema_common.fbs");
    std::string directory_common = schema_path_common.substr(0, schema_path_common.find("fcp/tracing/tracing_schema_common.fbs"));
    const char *include_directories[] = {
                 directory_common.c_str(), nullptr};
    parser.Parse(schema_file.c_str(), include_directories);
    std::string jsongen;
    parser.SetRootType("ResultExpectError");
    GenerateText(parser, flatbuf_bytes, &jsongen);
    return jsongen;
  }
  static flatbuffers::Offset<ResultExpectError> Create(absl::string_view expectation, absl::string_view file_name, std::int32_t line, flatbuffers::FlatBufferBuilder* fbb) {
    auto expectation__ = fbb->CreateString(expectation.data(), expectation.size());
    auto file_name__ = fbb->CreateString(file_name.data(), file_name.size());
    return CreateResultExpectError(*fbb, expectation__, file_name__, line);
  }
  using TupleType = std::tuple<std::string, std::string, std::int32_t>;
  static TupleType MakeTuple(const ResultExpectError* table) {
    return std::make_tuple(table->expectation()->str(), table->file_name()->str(), table->line());
  }
};
static internal::TracingTraitsRegistrar<ResultExpectError> registrar_ResultExpectError;
template<> class TracingTraits<ResultExpectStatusError>: public TracingTraitsBase {
 public:
  static constexpr TracingTag kTag = TracingTag("STAT");
  static constexpr TracingSeverity kSeverity = fcp::TracingSeverity::kError;
  static constexpr bool kIsSpan = false;
  const char* Name() const override { return "ResultExpectStatusError"; }
  TracingSeverity Severity() const override {
    return fcp::TracingSeverity::kError;
  }
  std::string TextFormat(const flatbuffers::DetachedBuffer& buf) const override {
    return flatbuffers::FlatBufferToString(buf.data(), ResultExpectStatusErrorTypeTable());
  }
  std::string JsonStringFormat(const uint8_t* flatbuf_bytes) const override {
    flatbuffers::Parser parser;
    std::string schema_file;
    std::string fbs_file = "fcp/base/tracing_schema.fbs";
    flatbuffers::LoadFile(GetDataPath(fbs_file).c_str(), true, &schema_file);
    std::string schema_path_common = GetDataPath("fcp/tracing/tracing_schema_common.fbs");
    std::string directory_common = schema_path_common.substr(0, schema_path_common.find("fcp/tracing/tracing_schema_common.fbs"));
    const char *include_directories[] = {
                 directory_common.c_str(), nullptr};
    parser.Parse(schema_file.c_str(), include_directories);
    std::string jsongen;
    parser.SetRootType("ResultExpectStatusError");
    GenerateText(parser, flatbuf_bytes, &jsongen);
    return jsongen;
  }
  static flatbuffers::Offset<ResultExpectStatusError> Create(TracingStatusCode expected_code, TracingStatusCode actual_code, absl::string_view message, absl::string_view file_name, std::int32_t line, flatbuffers::FlatBufferBuilder* fbb) {
    auto message__ = fbb->CreateString(message.data(), message.size());
    auto file_name__ = fbb->CreateString(file_name.data(), file_name.size());
    return CreateResultExpectStatusError(*fbb, expected_code, actual_code, message__, file_name__, line);
  }
  using TupleType = std::tuple<TracingStatusCode, TracingStatusCode, std::string, std::string, std::int32_t>;
  static TupleType MakeTuple(const ResultExpectStatusError* table) {
    return std::make_tuple(table->expected_code(), table->actual_code(), table->message()->str(), table->file_name()->str(), table->line());
  }
};
static internal::TracingTraitsRegistrar<ResultExpectStatusError> registrar_ResultExpectStatusError;
} // namespace fcp

#endif  // FCP_BASE_TRACING_SCHEMA_H