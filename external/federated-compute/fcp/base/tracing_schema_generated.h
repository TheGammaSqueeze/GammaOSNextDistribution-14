// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRACINGSCHEMA_H_
#define FLATBUFFERS_GENERATED_TRACINGSCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

#include "fcp/tracing/tracing_schema_common_generated.h"

struct ResultExpectError;
struct ResultExpectErrorBuilder;
struct ResultExpectErrorT;

struct ResultExpectStatusError;
struct ResultExpectStatusErrorBuilder;
struct ResultExpectStatusErrorT;

struct ProtoParseFailure;
struct ProtoParseFailureBuilder;
struct ProtoParseFailureT;

inline const flatbuffers::TypeTable *ResultExpectErrorTypeTable();

inline const flatbuffers::TypeTable *ResultExpectStatusErrorTypeTable();

inline const flatbuffers::TypeTable *ProtoParseFailureTypeTable();

enum TracingStatusCode : int16_t {
  TracingStatusCode_Ok = 0,
  TracingStatusCode_Cancelled = 1,
  TracingStatusCode_Unknown = 2,
  TracingStatusCode_InvalidArgument = 3,
  TracingStatusCode_DeadlineExceeded = 4,
  TracingStatusCode_NotFound = 5,
  TracingStatusCode_AlreadyExists = 6,
  TracingStatusCode_PermissionDenied = 7,
  TracingStatusCode_ResourceExhausted = 8,
  TracingStatusCode_FailedPrecondition = 9,
  TracingStatusCode_Aborted = 10,
  TracingStatusCode_OutOfRange = 11,
  TracingStatusCode_Unimplemented = 12,
  TracingStatusCode_Internal = 13,
  TracingStatusCode_Unavailable = 14,
  TracingStatusCode_DataLoss = 15,
  TracingStatusCode_Unauthenticated = 16,
  TracingStatusCode_MIN = TracingStatusCode_Ok,
  TracingStatusCode_MAX = TracingStatusCode_Unauthenticated
};

inline const TracingStatusCode (&EnumValuesTracingStatusCode())[17] {
  static const TracingStatusCode values[] = {
    TracingStatusCode_Ok,
    TracingStatusCode_Cancelled,
    TracingStatusCode_Unknown,
    TracingStatusCode_InvalidArgument,
    TracingStatusCode_DeadlineExceeded,
    TracingStatusCode_NotFound,
    TracingStatusCode_AlreadyExists,
    TracingStatusCode_PermissionDenied,
    TracingStatusCode_ResourceExhausted,
    TracingStatusCode_FailedPrecondition,
    TracingStatusCode_Aborted,
    TracingStatusCode_OutOfRange,
    TracingStatusCode_Unimplemented,
    TracingStatusCode_Internal,
    TracingStatusCode_Unavailable,
    TracingStatusCode_DataLoss,
    TracingStatusCode_Unauthenticated
  };
  return values;
}

inline const char * const *EnumNamesTracingStatusCode() {
  static const char * const names[18] = {
    "Ok",
    "Cancelled",
    "Unknown",
    "InvalidArgument",
    "DeadlineExceeded",
    "NotFound",
    "AlreadyExists",
    "PermissionDenied",
    "ResourceExhausted",
    "FailedPrecondition",
    "Aborted",
    "OutOfRange",
    "Unimplemented",
    "Internal",
    "Unavailable",
    "DataLoss",
    "Unauthenticated",
    nullptr
  };
  return names;
}

inline const char *EnumNameTracingStatusCode(TracingStatusCode e) {
  if (flatbuffers::IsOutRange(e, TracingStatusCode_Ok, TracingStatusCode_Unauthenticated)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTracingStatusCode()[index];
}

struct ResultExpectErrorT : public flatbuffers::NativeTable {
  typedef ResultExpectError TableType;
  std::string expectation{};
  std::string file_name{};
  int32_t line = 0;
};

struct ResultExpectError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResultExpectErrorT NativeTableType;
  typedef ResultExpectErrorBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResultExpectErrorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPECTATION = 4,
    VT_FILE_NAME = 6,
    VT_LINE = 8
  };
  const flatbuffers::String *expectation() const {
    return GetPointer<const flatbuffers::String *>(VT_EXPECTATION);
  }
  const flatbuffers::String *file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_NAME);
  }
  int32_t line() const {
    return GetField<int32_t>(VT_LINE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EXPECTATION) &&
           verifier.VerifyString(expectation()) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           VerifyField<int32_t>(verifier, VT_LINE, 4) &&
           verifier.EndTable();
  }
  ResultExpectErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResultExpectErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResultExpectError> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResultExpectErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResultExpectErrorBuilder {
  typedef ResultExpectError Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_expectation(flatbuffers::Offset<flatbuffers::String> expectation) {
    fbb_.AddOffset(ResultExpectError::VT_EXPECTATION, expectation);
  }
  void add_file_name(flatbuffers::Offset<flatbuffers::String> file_name) {
    fbb_.AddOffset(ResultExpectError::VT_FILE_NAME, file_name);
  }
  void add_line(int32_t line) {
    fbb_.AddElement<int32_t>(ResultExpectError::VT_LINE, line, 0);
  }
  explicit ResultExpectErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResultExpectError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResultExpectError>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResultExpectError> CreateResultExpectError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> expectation = 0,
    flatbuffers::Offset<flatbuffers::String> file_name = 0,
    int32_t line = 0) {
  ResultExpectErrorBuilder builder_(_fbb);
  builder_.add_line(line);
  builder_.add_file_name(file_name);
  builder_.add_expectation(expectation);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResultExpectError> CreateResultExpectErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *expectation = nullptr,
    const char *file_name = nullptr,
    int32_t line = 0) {
  auto expectation__ = expectation ? _fbb.CreateString(expectation) : 0;
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  return CreateResultExpectError(
      _fbb,
      expectation__,
      file_name__,
      line);
}

flatbuffers::Offset<ResultExpectError> CreateResultExpectError(flatbuffers::FlatBufferBuilder &_fbb, const ResultExpectErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResultExpectStatusErrorT : public flatbuffers::NativeTable {
  typedef ResultExpectStatusError TableType;
  TracingStatusCode expected_code = TracingStatusCode_Ok;
  TracingStatusCode actual_code = TracingStatusCode_Ok;
  std::string message{};
  std::string file_name{};
  int32_t line = 0;
};

struct ResultExpectStatusError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResultExpectStatusErrorT NativeTableType;
  typedef ResultExpectStatusErrorBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResultExpectStatusErrorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPECTED_CODE = 4,
    VT_ACTUAL_CODE = 6,
    VT_MESSAGE = 8,
    VT_FILE_NAME = 10,
    VT_LINE = 12
  };
  TracingStatusCode expected_code() const {
    return static_cast<TracingStatusCode>(GetField<int16_t>(VT_EXPECTED_CODE, 0));
  }
  TracingStatusCode actual_code() const {
    return static_cast<TracingStatusCode>(GetField<int16_t>(VT_ACTUAL_CODE, 0));
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::String *file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_NAME);
  }
  int32_t line() const {
    return GetField<int32_t>(VT_LINE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_EXPECTED_CODE, 2) &&
           VerifyField<int16_t>(verifier, VT_ACTUAL_CODE, 2) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           VerifyField<int32_t>(verifier, VT_LINE, 4) &&
           verifier.EndTable();
  }
  ResultExpectStatusErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResultExpectStatusErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResultExpectStatusError> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResultExpectStatusErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResultExpectStatusErrorBuilder {
  typedef ResultExpectStatusError Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_expected_code(TracingStatusCode expected_code) {
    fbb_.AddElement<int16_t>(ResultExpectStatusError::VT_EXPECTED_CODE, static_cast<int16_t>(expected_code), 0);
  }
  void add_actual_code(TracingStatusCode actual_code) {
    fbb_.AddElement<int16_t>(ResultExpectStatusError::VT_ACTUAL_CODE, static_cast<int16_t>(actual_code), 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(ResultExpectStatusError::VT_MESSAGE, message);
  }
  void add_file_name(flatbuffers::Offset<flatbuffers::String> file_name) {
    fbb_.AddOffset(ResultExpectStatusError::VT_FILE_NAME, file_name);
  }
  void add_line(int32_t line) {
    fbb_.AddElement<int32_t>(ResultExpectStatusError::VT_LINE, line, 0);
  }
  explicit ResultExpectStatusErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResultExpectStatusError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResultExpectStatusError>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResultExpectStatusError> CreateResultExpectStatusError(
    flatbuffers::FlatBufferBuilder &_fbb,
    TracingStatusCode expected_code = TracingStatusCode_Ok,
    TracingStatusCode actual_code = TracingStatusCode_Ok,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::String> file_name = 0,
    int32_t line = 0) {
  ResultExpectStatusErrorBuilder builder_(_fbb);
  builder_.add_line(line);
  builder_.add_file_name(file_name);
  builder_.add_message(message);
  builder_.add_actual_code(actual_code);
  builder_.add_expected_code(expected_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResultExpectStatusError> CreateResultExpectStatusErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    TracingStatusCode expected_code = TracingStatusCode_Ok,
    TracingStatusCode actual_code = TracingStatusCode_Ok,
    const char *message = nullptr,
    const char *file_name = nullptr,
    int32_t line = 0) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  return CreateResultExpectStatusError(
      _fbb,
      expected_code,
      actual_code,
      message__,
      file_name__,
      line);
}

flatbuffers::Offset<ResultExpectStatusError> CreateResultExpectStatusError(flatbuffers::FlatBufferBuilder &_fbb, const ResultExpectStatusErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProtoParseFailureT : public flatbuffers::NativeTable {
  typedef ProtoParseFailure TableType;
  std::string type{};
};

struct ProtoParseFailure FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProtoParseFailureT NativeTableType;
  typedef ProtoParseFailureBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProtoParseFailureTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           verifier.EndTable();
  }
  ProtoParseFailureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProtoParseFailureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProtoParseFailure> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProtoParseFailureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProtoParseFailureBuilder {
  typedef ProtoParseFailure Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(ProtoParseFailure::VT_TYPE, type);
  }
  explicit ProtoParseFailureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProtoParseFailure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProtoParseFailure>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProtoParseFailure> CreateProtoParseFailure(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0) {
  ProtoParseFailureBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProtoParseFailure> CreateProtoParseFailureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  return CreateProtoParseFailure(
      _fbb,
      type__);
}

flatbuffers::Offset<ProtoParseFailure> CreateProtoParseFailure(flatbuffers::FlatBufferBuilder &_fbb, const ProtoParseFailureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ResultExpectErrorT *ResultExpectError::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ResultExpectErrorT>(new ResultExpectErrorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ResultExpectError::UnPackTo(ResultExpectErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = expectation(); if (_e) _o->expectation = _e->str(); }
  { auto _e = file_name(); if (_e) _o->file_name = _e->str(); }
  { auto _e = line(); _o->line = _e; }
}

inline flatbuffers::Offset<ResultExpectError> ResultExpectError::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResultExpectErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResultExpectError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResultExpectError> CreateResultExpectError(flatbuffers::FlatBufferBuilder &_fbb, const ResultExpectErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResultExpectErrorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _expectation = _o->expectation.empty() ? 0 : _fbb.CreateString(_o->expectation);
  auto _file_name = _o->file_name.empty() ? 0 : _fbb.CreateString(_o->file_name);
  auto _line = _o->line;
  return CreateResultExpectError(
      _fbb,
      _expectation,
      _file_name,
      _line);
}

inline ResultExpectStatusErrorT *ResultExpectStatusError::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ResultExpectStatusErrorT>(new ResultExpectStatusErrorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ResultExpectStatusError::UnPackTo(ResultExpectStatusErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = expected_code(); _o->expected_code = _e; }
  { auto _e = actual_code(); _o->actual_code = _e; }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
  { auto _e = file_name(); if (_e) _o->file_name = _e->str(); }
  { auto _e = line(); _o->line = _e; }
}

inline flatbuffers::Offset<ResultExpectStatusError> ResultExpectStatusError::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResultExpectStatusErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResultExpectStatusError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResultExpectStatusError> CreateResultExpectStatusError(flatbuffers::FlatBufferBuilder &_fbb, const ResultExpectStatusErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResultExpectStatusErrorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _expected_code = _o->expected_code;
  auto _actual_code = _o->actual_code;
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  auto _file_name = _o->file_name.empty() ? 0 : _fbb.CreateString(_o->file_name);
  auto _line = _o->line;
  return CreateResultExpectStatusError(
      _fbb,
      _expected_code,
      _actual_code,
      _message,
      _file_name,
      _line);
}

inline ProtoParseFailureT *ProtoParseFailure::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProtoParseFailureT>(new ProtoParseFailureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProtoParseFailure::UnPackTo(ProtoParseFailureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
}

inline flatbuffers::Offset<ProtoParseFailure> ProtoParseFailure::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProtoParseFailureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProtoParseFailure(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProtoParseFailure> CreateProtoParseFailure(flatbuffers::FlatBufferBuilder &_fbb, const ProtoParseFailureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProtoParseFailureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  return CreateProtoParseFailure(
      _fbb,
      _type);
}

inline const flatbuffers::TypeTable *TracingStatusCodeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TracingStatusCodeTypeTable
  };
  static const char * const names[] = {
    "Ok",
    "Cancelled",
    "Unknown",
    "InvalidArgument",
    "DeadlineExceeded",
    "NotFound",
    "AlreadyExists",
    "PermissionDenied",
    "ResourceExhausted",
    "FailedPrecondition",
    "Aborted",
    "OutOfRange",
    "Unimplemented",
    "Internal",
    "Unavailable",
    "DataLoss",
    "Unauthenticated"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 17, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResultExpectErrorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "expectation",
    "file_name",
    "line"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResultExpectStatusErrorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TracingStatusCodeTypeTable
  };
  static const char * const names[] = {
    "expected_code",
    "actual_code",
    "message",
    "file_name",
    "line"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProtoParseFailureTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

#endif  // FLATBUFFERS_GENERATED_TRACINGSCHEMA_H_